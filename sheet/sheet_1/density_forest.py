


<!DOCTYPE html>
<html lang="en">
<head>
<title>density_forest.py - heiBOX</title>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="File, Collaboration, Team, Organization" />


<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />


<meta property="og:type" content="object" />
<meta property="og:site_name" content="heibox.uni-heidelberg.de">
<meta property="og:url" content="https://heibox.uni-heidelberg.de/f/9bd2fca2e0174ea48f87/" />
<meta property="og:title" content="density_forest.py" />
<meta property="og:image" content="https://heibox.uni-heidelberg.de/media/img/file/192/file.png" />
<meta property="og:description" content="Share link for density_forest.py." />

<meta http-equiv="x-ua-compatible" content="ie=edge" />
<link rel="icon" href="/media/custom/img/favicon.ico" type="image/x-icon" id="favicon">
<link rel="apple-touch-icon" href="/media/favicons/favicon.png">
<link rel="stylesheet" type="text/css" href="/media/fontawesome/css/fontawesome-all.min.css" />
<link rel="stylesheet" type="text/css" href="/media/css/sf_font3/iconfont.css" />
<link rel="stylesheet" type="text/css" href="/media/css/seafile-ui.css" />
<link rel="stylesheet" type="text/css" href="/media/css/seahub_react.css?t=1398068110" />


    <link href="/media/assets/frontend/static/css/commons.85b372e7.css" rel="stylesheet" />



<link rel="stylesheet" type="text/css" href="/media/custom/urz.css" />

</head>

<body>
    <div id="wrapper" class="en"></div>
    <div id="modal-wrapper" class="en"></div>
    

<script type="text/javascript">
    window.app = {
        config: {
            mediaUrl: '/media/',
            logoPath: 'custom/img/heibox_logo.png',
            logoWidth: '142',
            logoHeight: '48',
            faviconPath: 'custom/img/favicon.ico',
            loginBGPath: 'img/login-bg.jpg',
            siteTitle: 'heiBOX',
            siteName: 'heibox.uni\u002Dheidelberg.de',
            siteRoot: '/',
            loginUrl: '/accounts/login/',
            isPro: 'True',
            isDBSqlite3:  false ,
            isDocs: 'False',
            lang: 'en',
            fileServerRoot: 'https://heibox.uni-heidelberg.de/seafhttp/',
            enableRepoAutoDel:  true ,
            useGoFileserver:  true ,
            serviceURL: 'https://heibox.uni-heidelberg.de',
            seafileVersion: '11.0.16',
            avatarURL: 'https://heibox.uni-heidelberg.de/media/avatars/default.png'
        },
        pageOptions: {
            csrfToken: "uQCK6wPmQ3EeXnj5Fy9TM0yCVJkaT5r6GB0NQsm3mT0xHFmwZjWtDdZ9tBxJ2Nsd",
            seafileCollabServer: '',
            name: "",
            contactEmail: "",
            username: "",
            guideEnabled:  false ,
            trashReposExpireDays:  null ,
            canAddRepo:  false ,
            canShareRepo:  false ,
            canAddGroup:  false ,
            groupImportMembersExtraMsg: "",
            canGenerateShareLink:  false ,
            canGenerateUploadLink:  false ,
            canSendShareLinkEmail:  false ,
            canViewOrg:'',
            fileAuditEnabled:   false , 
            enableFileComment:  false ,
            folderPermEnabled:  false ,
            enableResetEncryptedRepoPassword: '',
            isEmailConfigured: '',
            enableUploadFolder: 'True',
            enableResumableFileUpload: 'True',
            resumableUploadFileBlockSize: '',
            // storage backends
            storages: (function () {
              var storages = [];
              
              return storages;
            })(),
            // library template
            libraryTemplates: (function () {
              var libraryTemplates = [];
              
              return libraryTemplates;
            })(),
            enableRepoSnapshotLabel:  false ,
            shareLinkForceUsePassword:  false ,
            shareLinkPasswordMinLength: 12,
            shareLinkPasswordStrengthLevel: 1,
            sideNavFooterCustomHtml: "",
            aboutDialogCustomHtml: "",
            maxFileName: "255",
            canPublishRepo:  false ,
            enableEncryptedLibrary:  false ,
            enableRepoHistorySetting:  false ,
            isSystemStaff:  false ,
            thumbnailSizeForOriginal: 1024,
            repoPasswordMinLength: 12,
            canAddPublicRepo:  false ,
            enableOCMViaWebdav:  false ,
            enableOCM:  false ,
            ocmRemoteServers: (function () {
              var servers = [];
              
              return servers;
            })(),
            canInvitePeople:  false ,
            customNavItems:  [] ,
            enableShowContactEmailWhenSearchUser:  false ,
            enableShowLoginIDWhenSearchUser:  false ,
            
            
            
            enableTC:  false ,
            enableSSOToThirdpartWebsite:  false ,
            enableVideoThumbnail:  false ,
            showLogoutIcon:  false ,
            additionalShareDialogNote:  null ,
            additionalAppBottomLinks:  null ,
            additionalAboutDialogLinks:  null ,
            enableOnlyoffice:  false ,
            onlyofficeConverterExtensions:  ['.docm', '.doc', '.dotx', '.dotm', '.dot', '.odt', '.fodt', '.ott', '.xlsm', '.xls', '.xltx', '.xltm', '.xlt', '.ods', '.fods', '.ots', '.pptm', '.ppt', '.ppsx', '.ppsm', '.pps', '.potx', '.potm', '.pot', '.odp', '.fodp', '.otp', '.rtf', '.mht', '.html', '.htm', '.xml', '.epub', '.fb2'] ,
            enableSeadoc:  false ,
            enableSeafileAI:  false ,
            canSetExProps:  false ,
            enableSeaTableIntegration:  false ,
            isOrgContext:  false ,
        }
     };
</script>
<script src="/media/assets/scripts/i18n/en/djangojs.js?v=11.0.16"></script>

<script type="text/javascript">
  window.shared = {
    pageOptions: {
      repoID: '25418ad1-c3f5-4895-aa5c-123fb938ac86',
      filePath: '/Lehre/generative\u002Dneural\u002Dnetworks/exercises/generative\u002Dnn/ex01/density_forest.py',
      sharedToken: '9bd2fca2e0174ea48f87',
      trafficOverLimit: false,
      fileName: 'density_forest.py',
      fileSize: 9243,
      rawPath: 'https://heibox.uni\u002Dheidelberg.de/seafhttp/files/ddf27f49\u002Dea76\u002D4828\u002D8ffb\u002Dd899953ae022/density_forest.py',
      sharedBy: 'Ullrich KÃ¶the',
      siteName: 'heibox.uni-heidelberg.de',
      enableWatermark: false,
      canDownload: true,
      canEdit: false,
      fileContent: '# usage: see docstring of class DensityForest\u000D\u000A\u000D\u000Aimport numpy as np\u000D\u000Afrom joblib import Parallel, delayed\u000D\u000A\u000D\u000Aclass Node:\u000D\u000A    pass\u000D\u000A\u000D\u000A\u000D\u000Aclass DensityTree:\u000D\u000A    def __init__(self, n_min\u003D10):\u000D\u000A        \u0027\u0027\u0027 n_min: minimum required number of instances in leaf nodes\u000D\u000A        \u0027\u0027\u0027\u000D\u000A        self.n_min \u003D n_min\u000D\u000A        self.bins \u003D {\u000D\u000A            \u0027count\u0027: [],\u000D\u000A            \u0027mean\u0027: [],\u000D\u000A            \u0027cov\u0027: []\u000D\u000A        }\u000D\u000A\u000D\u000A    def fit(self, features, D_try\u003DNone):\u000D\u000A        \u0027\u0027\u0027\u000D\u000A        features: the feature matrix of the training sets\u000D\u000A        \u0027\u0027\u0027\u000D\u000A        N, D \u003D features.shape\u000D\u000A\u000D\u000A        if D_try is None:\u000D\u000A            D_try \u003D int(np.sqrt(D)) # number of features to consider for each split decision\u000D\u000A\u000D\u000A        # initialize the root node\u000D\u000A        self.root \u003D Node()\u000D\u000A        self.root.features  \u003D features\u000D\u000A\u000D\u000A        # build the tree\u000D\u000A        stack \u003D [self.root]\u000D\u000A        while len(stack):\u000D\u000A            node \u003D stack.pop()\u000D\u000A            active_indices \u003D self.select_active_indices(D, D_try)\u000D\u000A            left, right \u003D self.make_split_node(node, active_indices)\u000D\u000A            if left is None: # no split found\u000D\u000A                self.make_leaf_node(node)\u000D\u000A            else:\u000D\u000A                stack.append(left)\u000D\u000A                stack.append(right)\u000D\u000A\u000D\u000A        self.weights_ \u003D np.array(self.bins[\u0027count\u0027])\u000D\u000A        self.weights_ \u003D self.weights_ / self.weights_.sum()\u000D\u000A        self.means_ \u003D np.array(self.bins[\u0027mean\u0027])\u000D\u000A        self.covariances_ \u003D np.array(self.bins[\u0027cov\u0027])\u000D\u000A        self.n_components \u003D self.weights_.shape[0]\u000D\u000A\u000D\u000A    def make_split_node(self, node, indices):\u000D\u000A        \u0027\u0027\u0027\u000D\u000A        node: the node to be split\u000D\u000A        indices: a numpy array of length \u0027D_try\u0027, containing the feature\u000D\u000A                         indices to be considered for the present split\u000D\u000A\u000D\u000A        return: None, None \u002D\u002D if no suitable split has been found, or\u000D\u000A                left, right \u002D\u002D the children of the split\u000D\u000A        \u0027\u0027\u0027\u000D\u000A\u000D\u000A        # find best feature j_min (among \u0027indices\u0027) and best threshold t_min for the split\u000D\u000A        l_min \u003D float(\u0027inf\u0027)  # upper bound for the loss, later the loss of the best split\u000D\u000A        j_min, t_min \u003D None, None\u000D\u000A\u000D\u000A        for j in indices:\u000D\u000A            thresholds \u003D self.find_thresholds(node, j)\u000D\u000A\u000D\u000A            # compute loss for each threshold\u000D\u000A            for t in thresholds:\u000D\u000A                loss \u003D self.compute_loss_for_split(node, j, t)\u000D\u000A\u000D\u000A                # remember the best split so far\u000D\u000A                # (the condition is never True when loss \u003D float(\u0027inf\u0027) )\u000D\u000A                if loss \u003C l_min:\u000D\u000A                    l_min \u003D loss\u000D\u000A                    j_min \u003D j\u000D\u000A                    t_min \u003D t\u000D\u000A\u000D\u000A        if j_min is None: # no split found\u000D\u000A            return None, None\u000D\u000A\u000D\u000A        # create children for the best split\u000D\u000A        left, right \u003D self.make_children(node, j_min, t_min)\u000D\u000A\u000D\u000A        # turn the current \u0027node\u0027 into a split node\u000D\u000A        # (store children and split condition)\u000D\u000A        node.left \u003D left\u000D\u000A        node.right \u003D right\u000D\u000A        node.split_index \u003D j_min\u000D\u000A        node.threshold \u003D t_min\u000D\u000A\u000D\u000A        return left, right\u000D\u000A\u000D\u000A    def select_active_indices(self, D, D_try):\u000D\u000A        \u0027\u0027\u0027 return a 1\u002DD array with D_try randomly selected indices from 0...(D\u002D1).\u000D\u000A        \u0027\u0027\u0027\u000D\u000A        return np.random.choice(range(D), size\u003DD_try, replace\u003DFalse)\u000D\u000A\u000D\u000A    def find_thresholds(self, node, j):\u000D\u000A        \u0027\u0027\u0027 return: a 1\u002DD array with all possible thresholds along feature j\u000D\u000A        \u0027\u0027\u0027\u000D\u000A        if node.features.shape[0] / 2 \u003C self.n_min:\u000D\u000A            return []\u000D\u000A        sort \u003D np.sort(node.features[:,j])\u000D\u000A        t \u003D (sort[:\u002D1] + sort[1:]) / 2\u000D\u000A        if self.n_min \u003E 1:\u000D\u000A            t \u003D t[(self.n_min\u002D1): (\u002Dself.n_min+1)]\u000D\u000A        return t\u000D\u000A\u000D\u000A    def make_children(self, node, j, t):\u000D\u000A        \u0027\u0027\u0027 execute the split in feature j at threshold t\u000D\u000A\u000D\u000A            return: left, right \u002D\u002D the children of the split, with features\u000D\u000A                                   properly assigned according to the split\u000D\u000A        \u0027\u0027\u0027\u000D\u000A        left \u003D Node()\u000D\u000A        right \u003D Node()\u000D\u000A\u000D\u000A        left.features \u003D node.features[node.features[:,j] \u003C\u003D t]\u000D\u000A        right.features \u003D node.features[node.features[:,j] \u003E t]\u000D\u000A\u000D\u000A        return left, right\u000D\u000A\u000D\u000A    def entropy_gaussian(self, features):\u000D\u000A        \u0027\u0027\u0027 calculate the differential entropy of a d\u002Dvariate Gaussian density\u000D\u000A\u000D\u000A            features: a numpy array\u000D\u000A            return: entropy\u000D\u000A        \u0027\u0027\u0027\u000D\u000A        if features.shape[0] \u003D\u003D 1:\u000D\u000A            print(features)\u000D\u000A        sigma \u003D np.linalg.det(np.cov(features.T))\u000D\u000A        entropy \u003D np.multiply(np.power((2 * np.pi * np.e), features.shape[\u002D1]), sigma)\u000D\u000A        if entropy \u003C\u003D 0:\u000D\u000A            return 0\u000D\u000A        entropy \u003D np.log(entropy) / 2\u000D\u000A        if np.isnan(entropy):\u000D\u000A            entropy \u003D np.infty\u000D\u000A        return entropy\u000D\u000A\u000D\u000A\u000D\u000A    def compute_loss_for_split(self, node, j, t):\u000D\u000A        # return the loss if we would split the instance along feature j at threshold t\u000D\u000A        # or float(\u0027inf\u0027) if there is no feasible split\u000D\u000A        l_response \u003D node.features[node.features[:,j] \u003C\u003D t]\u000D\u000A        r_response \u003D node.features[node.features[:,j] \u003E t]\u000D\u000A        if len(l_response) \u003C\u003D 1 or len(r_response) \u003C\u003D 1:\u000D\u000A            return float(\u0027inf\u0027)\u000D\u000A\u000D\u000A        loss \u003D self.entropy_gaussian(l_response) + self.entropy_gaussian(r_response)\u000D\u000A        return loss\u000D\u000A\u000D\u000A    def make_leaf_node(self, node):\u000D\u000A        # turn node into a leaf node\u000D\u000A        self.bins[\u0027count\u0027].append(node.features.shape[0])\u000D\u000A        self.bins[\u0027mean\u0027].append(node.features.mean(0))\u000D\u000A        self.bins[\u0027cov\u0027].append(np.cov(node.features.T) + 1e\u002D6 * np.eye(node.features.shape[1]))\u000D\u000A\u000D\u000A    def sample(self, n_samples):\u000D\u000A        samples \u003D []\u000D\u000A\u000D\u000A        # Choose the components of samples\u000D\u000A        component_choices \u003D np.random.choice(self.n_components, size\u003Dn_samples, p\u003Dself.weights_)\u000D\u000A\u000D\u000A        for k in range(self.n_components):\u000D\u000A            # Compute the numbers of samples of the component k\u000D\u000A            n_k \u003D np.sum(component_choices \u003D\u003D k)\u000D\u000A            if n_k \u003E 0:\u000D\u000A                # Generate the samples from the normal distribution with the mean and the covariance matrix of component k\u000D\u000A                samples_k \u003D np.random.multivariate_normal(mean\u003Dself.means_[k],\u000D\u000A                                                          cov\u003Dself.covariances_[k],\u000D\u000A                                                          size\u003Dn_k)\u000D\u000A                samples.append(samples_k)\u000D\u000A\u000D\u000A        # Combine samples\u000D\u000A        samples \u003D np.vstack(samples)\u000D\u000A\u000D\u000A        # Shuffle samples\u000D\u000A        np.random.shuffle(samples)\u000D\u000A\u000D\u000A        return samples\u000D\u000A\u000D\u000Adef bootstrap_sampling(features):\u000D\u000A    \u0027\u0027\u0027return a bootstrap sample of features\u000D\u000A    \u0027\u0027\u0027\u000D\u000A    N \u003D features.shape[0]\u000D\u000A    inds \u003D np.random.choice(N, N, replace\u003DTrue)\u000D\u000A    return features[inds]\u000D\u000A\u000D\u000Aclass DensityForest():\u000D\u000A    \u0027\u0027\u0027\u000D\u000A    This class implements a random forest for density estimation, i.e. a\u000D\u000A    collection of density trees according to the method described in\u000D\u000A    Criminisi, Shotton \u0026 Konukoglu (2011): Decision Forests, Chapter 5\u000D\u000A    https://www.microsoft.com/en\u002Dus/research/wp\u002Dcontent/uploads/2016/02/CriminisiForests_FoundTrends_2011.pdf\u000D\u000A\u000D\u000A    Each tree performs a recursive subdivision of the training domain\u000D\u000A    into adaptive bins. For the trees to differ from one another, this\u000D\u000A    is randomized in the usual way (i.e. each tree only sees a bootstrap\u000D\u000A    sample of the training set, and only a random subset of the features\u000D\u000A    is considered in each split decision).\u000D\u000A    The bins of the trees contain a Gaussian fit to the instances within the\u000D\u000A    bin \u002D\u002D this works much better than a uniform distribution over the bin.\u000D\u000A\u000D\u000A    To sample from the forest, first a tree is selected uniformly at random.\u000D\u000A    Then a bin in that tree is selected according to the probability of each\u000D\u000A    bin, i.e. using the discrete distribution over the fraction of instances\u000D\u000A    located in each bin. Finally, a sample is generated from the Gaussian in\u000D\u000A    the selected bin.\u000D\u000A\u000D\u000A    Usage:\u000D\u000A\u000D\u000A    from density_forest import DensityForest\u000D\u000A\u000D\u000A    Xtrain \u003D ...  # load/create the training set\u000D\u000A    min_samples_per_bin \u003D 5\u000D\u000A\u000D\u000A    model \u003D DensityForest(n_min\u003Dmin_samples_per_bin)\u000D\u000A    model.fit(Xtrain)\u000D\u000A\u000D\u000A    samples \u003D model.sample(n_samples\u003D20)\u000D\u000A    \u0027\u0027\u0027\u000D\u000A    def __init__(self, n_trees\u003D10, n_min\u003D1):\u000D\u000A        self.n_trees \u003D n_trees\u000D\u000A        self.trees \u003D [DensityTree(n_min) for _ in range(self.n_trees)]\u000D\u000A\u000D\u000A    def fit(self, features):\u000D\u000A        self.trees \u003D Parallel(n_jobs\u003D\u002D1)(delayed(self.fit_tree)(tree, features) for tree in self.trees)\u000D\u000A\u000D\u000A    def fit_tree(self, tree, features):\u000D\u000A        bootstrap_features \u003D bootstrap_sampling(features)\u000D\u000A        tree.fit(bootstrap_features)\u000D\u000A        return tree\u000D\u000A\u000D\u000A    def sample(self, n_samples):\u000D\u000A        samples \u003D []\u000D\u000A\u000D\u000A        # Choose the trees of samples\u000D\u000A        tree_choices \u003D np.random.choice(self.n_trees, size\u003Dn_samples)\u000D\u000A\u000D\u000A        for k in range(self.n_trees):\u000D\u000A            # Compute the numbers of samples of the tree k\u000D\u000A            n_k \u003D np.sum(tree_choices \u003D\u003D k)\u000D\u000A            if n_k \u003E 0:\u000D\u000A                # Generate the samples from the tree k\u000D\u000A                samples_k \u003D self.trees[k].sample(n_k)\u000D\u000A                samples.append(samples_k)\u000D\u000A\u000D\u000A        # Combine samples\u000D\u000A        samples \u003D np.vstack(samples)\u000D\u000A\u000D\u000A        # Shuffle samples\u000D\u000A        np.random.shuffle(samples)\u000D\u000A\u000D\u000A        return samples',
      err: '',
      fileType: 'Text',
      fileExt: 'py',
      commitID: '' || 'fce20f4dffc6a65db3b2d37bda3148cd5b4c4e2e',
      enableShareLinkReportAbuse: false,
      
      // for 'view file in shared dir'
      
      prevImgPath: '',
      nextImgPath: '',
      assetsUrl: '',

      
    }
  };
</script>

    <script src="/media/assets/frontend/static/js/runtime.86db51cf.js" ></script>
<script src="/media/assets/frontend/static/js/commons.da76f83a.js" ></script>
<script src="/media/assets/frontend/static/js/sharedFileViewText.d2ab5b73.js" ></script>


</body>
</html>
